apiVersion: v1
kind: Service
metadata:
  name: k8intel-api-service
spec:
  # This makes the service accessible from outside the cluster via a cloud load balancer
  type: LoadBalancer 
  selector:
    app: k8intel-api
  ports:
    - name: http
      protocol: TCP
      port: 80 # The port the service will be available on
      targetPort: 8080 # The port on the container that traffic is sent to
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: k8intel-api-deployment
spec:
  replicas: 2 # Run two instances for high availability
  selector:
    matchLabels:
      app: k8intel-api
  template:
    metadata:
      labels:
        app: k8intel-api
    spec:
      containers:
      - name: k8intel-api-container
        # This is a placeholder that will be replaced by the Azure Pipeline during deployment
        image: #{ACR_NAME}#.azurecr.io/#{IMAGE_REPO}#:#{BUILD_ID}#
        ports:
        - containerPort: 8080
        env:
        # It's a best practice to manage secrets via a Kubernetes Secret, 
        # but for simplicity, we can define them here.
        # The pipeline would need to replace these values.
        - name: ConnectionStrings__DefaultConnection
          valueFrom:
            secretKeyRef:
              name: k8intel-secrets # Assumes a K8s secret named 'k8intel-secrets'
              key: db-connection-string
        - name: Jwt__Key
          valueFrom:
            secretKeyRef:
              name: k8intel-secrets
              key: jwt-key
        - name: Jwt__Issuer
          valueFrom:
            secretKeyRef:
              name: k8intel-secrets
              key: jwt-issuer
        - name: Jwt__Audience
          valueFrom:
            secretKeyRef:
              name: k8intel-secrets
              key: jwt-audience